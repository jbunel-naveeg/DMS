# Project Context

## Overview
This file is for uploading context about the DMS project. Please add any relevant information about:

- Project goals and objectives
- Architecture decisions
- Key features and functionality
- Dependencies and integrations
- Development notes
- Any other important context

## Project Structure
Based on the current codebase, this appears to be a Next.js application with:
- Authentication system
- Dashboard functionality
- Billing/Stripe integration
- Database migrations (Supabase)
- API routes for various services

---

*Add your context information below this line*
Naveeg – Technical Architecture & Implementation Reference
Tech Stack Overview
Naveeg is built as a monorepo SaaS platform that combines a Next.js frontend (deployed on Vercel) with a Supabase backend. It integrates multiple services to automate website creation and management for solopreneurs and SMEs. Key technologies include:
Frontend: Next.js (React) applications, providing a Shopify-style dashboard and a public marketing site. The UI is built with Tailwind CSS and a shared component library (shadcn/UI) for consistency.
Backend: Supabase (PostgreSQL database with Row-Level Security, Authentication, and Edge Functions). Supabase handles data persistence, auth (email/password and Google OAuth), and custom server logic in a secure, hosted environment.
Hosting & Site Provisioning: 10Web’s white-labeled WordPress hosting API for automated WordPress site creation, domain management, SSL, backups, and AI-assisted site generation. Naveeg fully white-labels 10Web, so end-users never see 10Web branding.
Payments: Stripe for subscription billing. Stripe Checkout and Customer Portal are used for seamless payment handling, with webhooks to synchronize subscription status back to Supabase.
Automations: n8n (self-hosted workflow automation) for background processes like sending welcome emails, running WP-CLI commands on sites, forwarding leads to Google Sheets/CRM, and other integrations.
AI Services: OpenAI APIs for AI features (e.g., content generation and a Q&A chatbot). The platform uses OpenAI’s embedding models to enable an on-site FAQ chatbot, and may leverage 10Web’s AI site generation for initial content.
Third-Party Integrations: Google services (Analytics GA4, Search Console, Business Profile/GMB, PageSpeed Insights) for enhanced Pro plan features. These allow users to connect their Google accounts and display analytics/SEO metrics in the dashboard.
All infrastructure is configured with GDPR compliance in mind: user data and hosting are kept in EU regions (Supabase and 10Web in Frankfurt) and pricing is VAT-inclusive for EU customers.
Monorepo Structure and Vercel Deployment
The repository is organized as a monorepo for maintaining multiple apps and shared packages in one place. The structure follows a conventional multi-app layout:
/apps/marketing – Next.js application for the public marketing website (landing pages, pricing, blog, etc.). This is deployed on Vercel to the root domain (e.g. naveeg.com). It is primarily static (with maybe minimal SSR for contact forms), focusing on content and sign-up CTA.
/apps/dashboard – Next.js application for the authenticated user dashboard. This is deployed on Vercel under a subdomain (e.g. app.naveeg.com), separate from the marketing site. All application pages (site editor, settings, etc.) live here and require login.
/packages/ui – A shared design system library (React components and styles) used by both apps for a consistent look and feel. Built with Tailwind CSS and Shadcn UI components for rapid UI development.
/packages/lib – A shared TypeScript utilities library for common code, such as API clients (for Supabase, Stripe, 10Web), types, and helper functions. This ensures both Next.js apps and Supabase Edge Functions use the same models and logic where applicable.
/supabase – Directory (managed via Supabase CLI) containing database migration SQL files, seed data, and Edge Function code (in a functions/ subdirectory). This is version-controlled to keep the schema and backend logic in sync with the codebase.
Each Next.js app is configured as a separate Vercel project, pointing to the respective subfolders. This allows deploying the marketing site and dashboard independently under different domains. Vercel’s monorepo support is used so that pushes to the main branch trigger deployments for both apps as needed. Environment-specific configuration (such as environment variables and domain mappings) is provided per project:
The marketing site project is mapped to the root domain (e.g. naveeg.com and www.naveeg.com).
The dashboard project is mapped to app.naveeg.com. It may also use a custom Vercel domain for previews (like naveeg-dashboard.vercel.app for staging).
Both Next.js apps share code from the /packages libraries via npm workspaces or a tool like Turborepo, ensuring no duplication. The monorepo approach simplifies sharing types and translations across projects and makes it easy to manage all components in one repository.
Routing and Separation of Marketing vs Dashboard
The marketing site (/apps/marketing) contains public-facing pages (Home, Features, Pricing, About, etc.) and handles things like blog content or marketing forms. It does not require authentication and is optimized for SEO and fast static delivery. The Next.js routing for marketing is straightforward (e.g., /, /pricing, /blog/[slug], etc.), and it might be statically generated or use Incremental Static Regeneration for content updates.
The dashboard (/apps/dashboard) is a protected app that requires users to log in. It likely uses Next.js App Routeror Pages Router with React components for various pages like /sites (overview of user’s websites), /sites/[id]/design, /sites/[id]/analytics, /settings, etc. Upon successful authentication, Supabase provides a session and JWT that the dashboard app uses for secure API calls. The dashboard will redirect unauthenticated users to the login page. We also ensure that navigation between the marketing site and app is smooth (for example, the marketing site’s "Login" or "Get Started" buttons link to the dashboard app’s login or onboarding flow).
Because the marketing site and dashboard are separate Next.js apps, they do not share runtime state. However, they can share static assets and components (through the ui package) and configuration (like Tailwind theme). They also share environment variables for things like Supabase URL and anon key, but each app has its own environment config in Vercel. The marketing site might include a contact form or newsletter signup, which could directly use Supabase (or a tool like ConvertKit) in public form. But primarily, all logged-in functionality is contained in the dashboard app to keep a clean separation.
On Vercel, each app is deployed in a production environment with the appropriate custom domains. Preview deployments for each app will use Vercel’s default domains (e.g., marketing-branch.vercel.app and dashboard-branch.vercel.app). Environment variables (like API keys, Supabase keys, Stripe keys) are set per project on Vercel to ensure, for example, the marketing site only has the ones it needs (perhaps just Supabase anon key for a contact form), while the dashboard has the full config.
Database Schema (Supabase) and Data Model
The Supabase Postgres database defines a multi-tenant schema where most data is scoped to a website (site instance) and secured by row-level security. Key tables in the schema include:
users – Stores user profile information for each account (UUID primary key matching Supabase Auth user ID). Fields include email, name, created_at, etc. (Supabase Auth manages the actual credentials). Each user upon sign-up gets an entry here via trigger or explicitly, so we can store profile data separate from auth metadata. (Global roles are not stored here; team roles are managed per site via team_members.)
plans – Defines subscription plans and features. Fields: id (primary key, e.g. “starter”, “pro”), name, price_eur(monthly price in EUR, VAT inclusive), stripe_price_id (the Stripe API Price ID for billing), and possibly a features_json or text describing the plan’s features. This is a reference table seeded with at least three entries: “Trial” (free, 7-day), “Starter” (€49/month), and “Pro” (€99/month). (The Trial may not be a formal plan in Stripe, but we represent trial state in our logic.)
websites – Each record represents a WordPress site created via 10Web for a user. Fields: id (UUID PK), owner_id (FK to users.id of the creator/owner), tenweb_id (integer ID of the site in 10Web), site_title, subdomain (the Naveeg subdomain chosen for the trial, e.g. mybiz.naveeg.online), primary_domain (current live domain – initially the naveeg.online subdomain, later a custom domain if connected), plan_id (FK to plans.id, null or “trial” during free trial), trial_starts_at, trial_ends_at (timestamps to track the 7-day trial period), upgraded_at (timestamp of subscribing to a paid plan), stripe_customer_id, stripe_subscription_id (for linking in Stripe), status (status of the site, e.g. active, canceled) and created_at. A new website row is created when a user completes onboarding (triggering site provisioning). Trial sites have plan_id = NULL or a special “trial” indicator, and trial_ends_at set to 7 days from creation. Upgrading the site sets plan_id to “starter” or “pro” and records the Stripe IDs.
entitlements – (Optional caching) A table for derived feature flags per website. Fields: website_id (FK), key(text feature name), value (jsonb, typically boolean). This can store capabilities like {"woocommerce": false}for a Starter site. It’s primarily used to cache or override computed entitlements for quick RLS checks. We may also implement entitlements as a view or a function that derives capabilities based on the site’s plan and trial status on the fly.
team_members – Manages multi-user access (team collaboration) on a website. Composite PK of (website_id, user_id). Fields: website_id (FK to websites), user_id (FK to users), role (enum: 'admin' or 'editor'), invited_at timestamp, accepted (boolean, for invite status). When a site is created, the owner is added here as an 'admin'. Pro plan sites allow inviting additional team members (as 'editor' role). Pending invites might be stored in this table or a separate invite token table.
billing_sessions – Logs interactions with Stripe Checkout and Customer Portal. Fields: id (UUID PK), website_id, user_id (who initiated the session), session_id (the Stripe Checkout Session ID or Portal session ID), session_type (enum: 'checkout' or 'portal'), created_at. This is mostly for record-keeping and security (e.g., to verify returned sessions). Webhooks from Stripe update the relevant website’s plan and subscription info, but this table logs the session initiation events.
domains – Tracks custom domains attached to a website. Fields: id (UUID PK), website_id (FK), domain (the custom domain name, e.g. "mycompany.com"), is_primary (bool – whether this domain is the current primary domain for the site), tenweb_domain_id (the ID reference from 10Web for this domain), status (e.g. pending, verified, active) and created_at. When a user on a paid plan connects a custom domain, we store it here and initiate verification/SSL provisioning via 10Web API. Only one domain can be primary at a time (others could be aliases or previous domains).
faq_docs – Stores FAQ documents or Q&A content for the AI chatbot feature. Fields: id (UUID PK), website_id (FK), file_path (path in Supabase Storage or URL of uploaded FAQ file), content_text (extracted text content, if stored), embedding (vector or JSON of the embedding for the content), status (processing status or enabled flag), created_at. When an admin (or editor) uploads an FAQ file, an Edge Function will process it (extract text, generate vector embeddings via OpenAI) and store the results here. This powers the site’s chatbot knowledge base.
leads – Stores lead form submissions captured from the WordPress sites. Fields: id (UUID PK), website_id(FK), name, email, message, and created_at. A default contact form on the site can send submissions to this table (via a WordPress plugin or an Edge Function webhook). The platform can display these leads in the dashboard and, via n8n, forward them to external systems (Sheets, CRM).
settings – Key-value store for miscellaneous site settings or configurations. Fields: website_id (FK, or null for global settings), key (text), value (JSONB), plus created_at. This can hold theme customization options (colors, fonts, etc.), integration tokens, or feature toggles. For example, when the user customizes their site’s theme in Naveeg, the choices are stored here and possibly synced to WordPress via 10Web API.
Additional supporting tables (not explicitly listed above) might include an invites table (for pending team invites with tokens), or a subscriptions table (if we prefer not to store Stripe subscription data directly in websites). However, the core schema above suffices by using websites.plan_id and related fields for subscription status.
Row-Level Security and Access Control
All tables are protected with Row-Level Security (RLS) policies to enforce tenant isolation and role-based permissions. Every data row associated with a specific website can only be accessed by users who are members of that website’s team. We utilize Supabase’s policy system with the authenticated user’s JWT (which includes their uid) to check membership:
Tenant Isolation: For each table that has a website_id (which is most tables except plans), select and update/delete permissions require that a row’s website_id is in the set of websites the user has access to. This is typically implemented by joining with the team_members table, e.g., a policy like: USING (website_id IN (SELECT website_id FROM team_members WHERE user_id = auth.uid())). This ensures one user cannot see or alter another user’s site data.
Role-Based Permissions: Within a site’s team, the role (admin vs editor) further restricts what actions can be taken:
Admins can perform all management operations on their site: upgrade/downgrade the plan, manage billing, invite or remove team members, connect domains, etc.. RLS policies allow only admins to, for example, update the websites.plan_id or insert rows in team_members (inviting someone).
Editors have limited permissions: they can modify content (pages, media, FAQ docs) and view data (basic analytics, leads), but cannot change site settings that affect billing or team composition. For instance, an editor might have SELECT access on most tables and INSERT access on leads or faq_docs, but not on billing_sessions or domains. Policies check the user’s role via a lookup in team_members and restrict accordingly.
Plan-Based Restrictions in RLS: Certain write actions are also gated by the site’s plan. For example, if a site is on Starter and does not have e-commerce entitlements, we might prevent insertion of WooCommerce products or disabling of such features at the database level for that site. This can be done by a check in the policy or via a computed entitlements view. For example, a policy on a hypothetical store_orders table might allow insert ONLY if (SELECT entitlements->>'woocommerce' FROM entitlement_view WHERE website_id = new.website_id) = 'true', effectively blocking use of the e-commerce feature for non-Pro plans. Similar approach can restrict creating team_members if plan doesn’t allow it, or uploading faq_docs if chatbot is not allowed. This way, even if a malicious client tried to call an API directly, the database would reject disallowed operations.
Public Data and Exceptions: The plans table contains no user-specific data, so it can be publicly readable (no RLS restriction) so that the application can load plan details for display. Similarly, certain reference data or global settings could be exposed with less restriction as needed. But all sensitive tables (websites, team_members, leads, etc.) have strict RLS.
In Supabase, enabling RLS and writing these policies ensures a defense in depth: the frontend will hide or disable UI controls based on role and plan, but even if someone bypasses the UI, the backend will enforce the rules. We also use Supabase’s built-in JWT claims. The user’s auth.uid() is used in policies; if needed we could include a custom claim for role or subscription, but generally a quick lookup to team_members suffices.
Feature Entitlements and Plan Gating
Naveeg offers a 7-day Free Trial for new sites, after which users must choose a paid plan. Features are enabled or disabled based on the user’s subscription plan or trial status:
Trial (Free for 7 days): The user has access to all features during the trial period. This includes Pro-level capabilities like e-commerce (WooCommerce store, Stripe payments), advanced analytics integrations, automations via n8n, AI chatbot, and custom domain on the platform side. However, trial sites are restricted to a Naveeg subdomain (no custom domain connection allowed until upgrade). The application prominently shows the trial as time-limited (e.g. “Trial – 7 days left” banner).
Starter Plan (€49/month): After trial, if the user opts for Starter, they get core website features but some advanced features become locked:
Basic website building and editing (add/delete pages, use 10Web builder, customize theme colors, etc.) – Allowed.
Backups & Restore – Allowed (the site continues to have automated backups via 10Web).
Basic Analytics – Allowed. They can see simple traffic stats (possibly via a simple built-in tracker or limited GA integration) and run PageSpeed Insights on demand.
WooCommerce & Stripe integration (Online store) – Not available. The UI for store/e-commerce features is hidden or shows an “Upgrade to Pro” prompt.
Advanced Google Integrations (GA4, Google Search Console, Google Business Profile) – Not available. Starter users won’t see the setup wizards for these services.
Automations (n8n workflows) – Not available. Any automation features (like syncing leads to Sheets, or other custom flows) are Pro-only and will be disabled for Starter.
AI Chatbot Widget – Not available on Starter. The option to upload FAQ or enable the chatbot will be gated with an upgrade prompt.
Team Members – Not available. Starter is single-user; the UI to invite team members is disabled (with an upgrade message).
Custom Domain – Possibly allowed on Starter in our model (to let Starter users use their own domain) – but this is a business decision. The recommendation is to gate custom domains to Pro only. We will assume Custom Domain requires Pro for maximum upsell, meaning Starter users would still use the Naveeg subdomain unless they upgrade to Pro.
Pro Plan (€99/month): Pro includes everything in Starter, plus all advanced features enabled:
E-commerce: WooCommerce plugin is installed, and a Stripe integration can be configured for online payments on the site.
Advanced Analytics: The user can connect Google Analytics 4 (we might create a property for them), verify their site with Google Search Console, and link a Google Business Profile. The dashboard will show GA4 traffic graphs, GSC search queries, and GMB insights for Pro users.
Automations: n8n workflows (like post-publish actions, lead forwarding, scheduled tasks) are available to Pro. Pro users might have certain automations pre-configured (like a nightly backup or a welcome email flow).
AI Chatbot: The FAQ upload and Q&A chatbot widget feature is enabled. Pro users can train a chatbot on their content and get a script to embed a chat widget on their site.
Team Members: Pro users can invite additional team members (editors) to collaborate on the site.
Custom Domain: Pro users can connect a custom domain (and even purchase a domain via the platform if supported). This includes automatic SSL certificate provisioning for the domain.
Additionally, Pro users have access to the Stripe Customer Portal to manage their subscription (update payment, cancel, etc.).
To implement this gating, Naveeg uses an entitlements system. When a site is in trial or on Pro, a boolean flag for each feature is true; on Starter, several flags are false. These entitlements can be computed in an Edge Function or via a database view each time the user session is issued. We may also store entitlements in the entitlements table for quick reference.
Entitlements Matrix: effectively, for each site we derive keys such as woocommerce, stripe_checkout, analytics_pro, automations, chatbot, team_editors, custom_domain. During Trial, all entitlements are TRUE (full access). On Starter, most advanced ones are FALSE (as listed above) and on Pro, all are TRUE. In particular, custom_domain might be set to FALSE on Starter if we decide to restrict it; otherwise it could be TRUE on Starter as well. This matrix is used both in the front-end (to conditionally show/hide UI) and in the back-end (RLS policies or function checks) to enforce limits.
Transition logic: When a site is created (trial start), we might store a special marker such as an entitlements.trial_pro = true or simply infer trial status by plan_id NULL + trial_ends_at in future. On trial expiry, a scheduled job or cron (see Edge Functions below) will automatically downgrade the site’s entitlements to Starter defaults if they haven’t upgraded. When the user upgrades via Stripe, the Stripe webhook will update the database (set plan_id to Starter/Pro, set upgraded_at) and trigger re-computation of entitlements (clearing any trial flag, and enabling the appropriate features for the chosen plan). If a subscription is canceled or expires, the system should downgrade the site’s plan (likely back to Starter-equivalent) at period end, and similarly adjust entitlements and notify the user.
The UI is plan-aware throughout: features that are not available have visual indicators (e.g., a disabled button or a lock icon with “Pro” label). For example, after a trial ends on Starter, the e-commerce section might still be visible but with a message “Upgrade to Pro to enable online store”. During the trial, those sections are fully usable. This approach (similar to Shopify or Wix) encourages upgrade by showing what’s possible but gating it with clear calls to action.
Supabase Edge Functions
Supabase Edge Functions (server-side TypeScript, running on Deno) handle the backend logic that cannot or should not be done directly from the client. We have implemented several key functions, deployed to Supabase’s Edge Function environment and invoked via HTTPS (with appropriate access control):
createWordPressSite – Onboarding Site Provisioning. This function is called when a new user completes the onboarding form to create a site. It takes inputs like site name, the user’s email (for WP admin), business category, and a desired subdomain. The function calls the 10Web API to provision a new WordPress website. For example, it sends a POST to /v1/hosting/website with payload including site_title, admin_email, and region (we use 10Web’s EU region, e.g. europe-west3 in Frankfurt). 10Web returns a website_id (their internal ID), which we store as websites.tenweb_id. Next, the function attaches our Naveeg trial subdomain: it calls 10Web’s domain API (POST /v1/hosting/websites/{id}/domain-name) with { domain_name: "<subdomain>.naveeg.online" } to add the subdomain. It then calls /v1/hosting/websites/{id}/domain-name/{domain_id}/default to set that as the primary domain, and requests a free SSL certificate via /v1/hosting/websites/{id}/certificate/free. In parallel, if the user provided business info indicating they need an e-commerce site, we could trigger AI site generation: for instance, call /v1/ai/generate_site with business type/name to let 10Web pre-build some pages. Alternatively, we could run an n8n workflow to install specific plugins (like WooCommerce) if needed. Upon success, this function inserts a new row in our websitestable with the trial info and sets up initial entitlements (trial = true). It also creates a team_members entry (owner as admin) and returns the site data to the frontend. This function is secured such that the calling user must match the owner_id and not exceed any quota (e.g., one trial at a time per user, if we enforce that).
generateWPAutologinLink – One-Click WP Admin Login. This function generates a single-use admin login URL for WordPress, so users can jump from Naveeg dashboard into the WordPress backend without a separate login. It calls the 10Web Account API GET /v1/account/websites/{website_id}/single?admin_url={...}, which returns a one-time token for WP admin login. We pass the site’s 10Web ID and the admin’s email (the WP admin user) in the request. The response provides a token that we combine into the WP Admin URL (e.g. https://<site-domain>/wp-admin/?twb_wp_login_token=...&email=admin@...). The function returns this URL, and the frontend can redirect the user to it. This spares the user from entering WP credentials and is secure (token expires quickly).
createCheckoutSession – Stripe Checkout Initialization. This function is invoked when an admin clicks “Upgrade” and selects a plan (Starter or Pro) in the dashboard. It creates a Stripe Checkout Session (using Stripe’s Node.js library) for the chosen plan’s Price ID. We include website_id (and perhaps plan_id) in the session’s metadata so we can identify which site to upgrade on webhook. The function stores a record in billing_sessions (type='checkout') with the Stripe session ID. It returns the Stripe session URL for the frontend to redirect the user to Stripe’s hosted payment page. This function will verify that the user is allowed to upgrade (e.g., user is admin of the site, and maybe that the site is still in trial or free).
handleStripeWebhooks – Stripe Webhook Handler. This is an endpoint Stripe calls to notify us of payment events. It listens for events like checkout.session.completed, invoice.paid, customer.subscription.updated, customer.subscription.deleted (cancellations), etc.. On a successful Checkout (session.completed for a new subscription), this function will:
Verify the Stripe signature (to ensure authenticity).
Parse the event, find the related website_id from the session metadata.
Update the websites table: set plan_id to the appropriate plan (“starter” or “pro”), set upgraded_at = NOW(), and store the stripe_subscription_id and stripe_customer_id if not already stored.
Mark any trial fields accordingly (e.g. trial has ended).
Insert an entry in an audit log or update billing_sessions as completed.
Recompute entitlements for that site (now based on the new plan).
For ongoing subscription events, if we receive a customer.subscription.deleted (meaning the user canceled or payment failed and subscription ended), the function will update that site’s plan_id back to a default (likely the free tier, which for us means Starter with no entitlements) and perhaps set a flag that the subscription is canceled at period end. We could also send an email or in-app notification to the user about the cancellation. All webhook events are handled server-side with no direct client involvement.
connectCustomDomain – Custom Domain Setup. When a Pro user submits a custom domain name to attach to their site, this Edge Function is called to orchestrate the process. It verifies the user is an admin and that the site is on a plan that allows custom domains (Pro). Then it calls 10Web’s domain API to add the domain: POST /v1/hosting/websites/{siteId}/domain-name with the provided domain. This returns a domain_name_id and possibly a DNS verification status. The function then calls /v1/hosting/websites/{siteId}/domain-name/{domainId}/default to set the new domain as primary. It also triggers SSL certificate issuance via /v1/hosting/websites/{siteId}/certificate/free. The domain record is inserted into our domains table with status “pending”. The function will periodically (or via webhook from 10Web if available) check the status of the domain’s DNS (10Web might have a field for whether DNS is pointed correctly). Once verified and SSL is active, it updates the status to “active”. If the user is on a higher plan that includes domain purchase, this function could also integrate with a domain registrar API to buy the domain, but initially we assume the user brings their own domain.
syncGoogleServices – Google Integrations Sync. This function (or set of functions) handles connecting to Google APIs (Analytics, Search Console, Business Profile). It is invoked after the user logs in with Google OAuth in the frontend. The function uses stored OAuth tokens to call Google APIs on behalf of the user:
For GA4: It can create a Google Analytics property for the website (or use an existing one) and retrieve a Tracking ID to embed in the site. It might also fetch analytics data (page views) to display in the dashboard.
For Search Console: It verifies the site (possibly by adding a DNS TXT record via 10Web’s DNS or uploading an HTML file through WordPress). Once verified, it can fetch search performance data (clicks, impressions) for the site.
For Business Profile (GMB): It could fetch the business’s profile info or help link the site with the GMB listing.
For PageSpeed Insights: It can call the PSI API to get performance scores for the site on demand.
These might be broken into separate functions (e.g., initAnalytics, fetchAnalyticsData, verifySearchConsole, etc.) for clarity. They run with elevated privileges (service role if needed) since they deal with external APIs and need to store tokens/keys securely.
processChatbotTrainingFile – AI Chatbot FAQ Processing. This function triggers when a user uploads an FAQ document (or requests to process existing content for Q&A). It will retrieve the file from Supabase Storage (if a file path is given) or accept raw text, then use an AI service to generate embeddings. For example, using OpenAI’s Embeddings API, it will break the document into chunks (per Q&A or paragraph), call the API to get vector embeddings, and store these vectors in the faq_docs table (possibly using a vector column if pgvector is enabled). It may also pre-generate a set of example question-answer pairs. After processing, it marks the faq_docs.status as ready. This function ensures only authorized users (team members of that site) can invoke it, and it runs with the necessary API keys for OpenAI. In the future, we could also fine-tune a small language model or use OpenAI’s QA API (like GPT-4 with a system prompt containing the FAQ context) rather than just embeddings. The outcome is that the site’s chatbot can now use these embeddings to answer visitors’ questions.
dailyTrialSweeper – Scheduled Trial Expiration Job. This is a scheduled (cron) function that runs, say, every night. It scans for any websites whose trial_ends_at has passed and that still have not been upgraded (no active Stripe subscription). For each such site, it will perform a downgrade: update the site’s plan to Starter (or a “Free” plan), which effectively disables the Pro entitlements. It can also send an email notification to the user that their trial expired and the site has been downgraded, with a link to upgrade if they change their mind. We ensure this runs with service role to override any RLS as needed.
All Edge Functions authenticate requests via Supabase JWT. When called from the client (via Supabase’s JS SDK functions.invoke), the JWT identifies the user. Each function begins by verifying the JWT and ensuring the user is authorized for the action (e.g., the user invoking createWordPressSite must be the one who will own the site; the user invoking createCheckoutSession must be an admin of that site, etc.). We also use environment variables in these functions for secrets: e.g., the 10Web API key, Stripe API secret and webhook secret, OpenAI API key, and any OAuth credentials or n8n webhook URLs. These are stored securely in the Supabase functions environment.
Billing and Stripe Integration
Stripe manages the subscription lifecycle for Naveeg’s paid plans. We have two paid tiers (Starter and Pro) and a free trial flow, implemented as follows:
Stripe Products and Prices: In Stripe, we set up products for “Naveeg Starter” and “Naveeg Pro” each with a monthly recurring price (49€ and 99€ respectively, tax inclusive). These correspond to the entries in our planstable (stripe_price_id links to Stripe). We may also create annual prices if offering annual billing (not mentioned initially, so default monthly).
Tax and VAT Handling: Prices are advertised as VAT-inclusive. To simplify, we can set Stripe tax behavior such that these prices are fixed (including VAT) for EU sales. Stripe allows inclusive tax pricing, or we can configure Stripe Tax with location-based VAT, but since our user base might be EU-centric, we include VAT in the price and label it clearly. We still collect customer location or at least have Stripe detect it for proper invoicing, but the amount remains 49/99 € final.
Free Trial Implementation: We do not use Stripe’s trial mechanisms here (no credit card up front). Instead, a new site starts with plan_id = NULL (or a “trial” status) and trial_ends_at = now() + 7 days in our DB. During this period, the user has full feature access without any Stripe subscription. The dashboard will continuously show how many days are left. If the user doesn’t upgrade by the end, our system (via dailyTrialSweeper) will downgrade the site to a restricted state. If they attempt to use a Pro feature after trial without upgrading, we prompt them to subscribe. This trial handling is thus mostly on our side (Supabase and UI), not Stripe.
Upgrade via Checkout: When a trial user clicks “Upgrade” (or a Starter user wants to go Pro), they go through Stripe Checkout. We invoke createCheckoutSession to create a Checkout Session for the chosen plan’s price. We pass mode: subscription and set it to collect payment details for a recurring subscription. The session’s success_url might point to the dashboard (with a status=success param) and cancel_url back to the pricing/upgrade page. Importantly, we include metadata: e.g., metadata: { website_id: <site-id>, plan: "pro" } so that on webhook we know which site to update. The user completes payment on Stripe’s hosted page.
Post-Checkout Handling: Stripe will redirect back, but we rely on the webhook (checkout.session.completed event) to finalize the upgrade. Our handleStripeWebhooks function (running with a Stripe webhook secret) will pick up the event and perform the upgrade steps as described earlier: update websites.plan_id, store subscription id, etc. Once our database is updated, the dashboard (which might be polling or listening via Supabase real-time) will reflect the new plan and unlock features. We also enable access to the Stripe Customer Portal now.
Customer Portal: For active subscribers (Pro plan mainly, possibly Starter if we treat it as subscription too), the dashboard provides a “Manage Billing” button. When clicked, we create a billing portal session via Stripe’s API (using the Stripe customer ID we saved). This returns a URL to Stripe’s customer portal where the user can update their payment method or cancel their subscription. We log this in billing_sessions (type 'portal'). We configure Stripe to send webhooks for customer.subscription.updated or canceled from the portal as well. If a user cancels via the portal, Stripe will send an event; our webhook function will mark the site as set to downgrade at period end. We might keep the site on Pro until the current billing cycle ends (which Stripe provides in the subscription current_period_end). After that, we downgrade to avoid cutting them off immediately since they paid for the period.
Downgrade and Cancellation: If a subscription ends (voluntarily canceled or payment failed), our policy is to revert the site to the Starter state (or a limited free state). This means the site itself isn’t deleted, but all Pro features are turned off. We would likely leave any custom domain attached for a short grace period and notify the user. If they don’t re-subscribe, we might eventually disable the custom domain (since only active subscribers get that benefit, per policy). For implementation, when we receive a subscription deletion event, we set plan_id back to Starter and could set a flag like canceled_at. A canceled user could still access their site on Starter features or decide to resubscribe to regain Pro features. If we needed to enforce custom domain removal, we could use 10Web API to remove the domain or mark it inactive (but that might be disruptive, so this requires a product decision).
Stripe Webhook Security: We set a webhook secret in the environment and our function uses it to verify each payload’s signature. This ensures only genuine Stripe events are processed.
Testing: In development, we use Stripe test mode with test API keys. We’ll have separate webhook signing secrets for test and production. All keys are stored in Vercel or Supabase function env vars, not in code. We also likely use Stripe’s CLI or dashboard to forward webhook events to our local dev when testing.
By leveraging Stripe’s hosted checkout and portal, we minimize the effort on handling payment UI and compliance. The approach follows widely used SaaS boilerplate patterns, ensuring reliability. Our focus remains on correctly handling the Stripe events to update the application state and enforcing the entitlements.
10Web API Integration (Hosting & WordPress Management)
Naveeg’s value proposition is automating WordPress site setup and management without exposing the complexity to the user. We use 10Web’s reseller API behind the scenes to achieve this. Key integration points with 10Web include:
Site Provisioning: (handled by createWordPressSite function as described) – We call POST /v1/hosting/website on 10Web to create a new WP site for the user. We choose the region (Frankfurt datacenter for EU) and provide initial admin credentials. The resulting site is essentially a WordPress instance hosted by 10Web under our reseller account.
Trial Subdomain Setup: Immediately after creating the site, we attach a subdomain on our brand domain. Using POST /v1/hosting/websites/{id}/domain-name with {domain_name: "<site>.naveeg.online"} adds our domain as an alias for the site. Then POST /v1/hosting/websites/{id}/domain-name/{domain_id}/defaultsets it as the primary domain. We also request a Let’s Encrypt SSL certificate via POST /v1/hosting/websites/{id}/certificate/free so that the trial site is accessible via HTTPS. We have a wildcard DNS entry for *.naveeg.online pointing to 10Web’s servers, so any subdomain will resolve for validation.
AI Site Generation: 10Web provides an AI service to generate site content and structure based on a business description. We may utilize POST /v1/ai/generate_site after site creation, sending the business type, name, and a brief description the user provided. This can populate the site with relevant pages and text/images, giving the user a starting point. If used, after generation we might also run an n8n workflow to tweak the site (e.g., ensure certain plugins are installed).
Content Management via Builder API: 10Web’s Builder API allows performing actions like creating and deleting pages, publishing changes, etc. For example, POST /v1/builder/websites/{site_id}/pages/blank/add creates a new blank page, and there are endpoints to list pages or delete pages. We can use these to implement a Pages UI in our dashboard. Advanced content editing (text, images) might be done via WordPress REST API endpoints if needed, or by redirecting into 10Web’s visual editor. Initially, we allow basic actions (create page, set homepage, etc.) via API and direct the user to the WordPress editor for complex edits (using the WP autologin link feature).
Plugin/Feature Management: If a user’s plan includes e-commerce, we ensure the WooCommerce plugin is installed on their WP site. This could be done via 10Web’s API if they support plugin management, or via WP-CLI through an n8n workflow (10Web allows running WP-CLI on the site). Similarly, for analytics integration, we might install a Google Analytics plugin or inject code via an API.
Backups: 10Web automatically creates backups. There are API endpoints like GET /v1/backup/{siteId} to list backups and POST /v1/backup/{siteId}/restore to restore. In our dashboard, we expose a “Backups” section for users to view available restore points and trigger restores. This is available to all plans (as it’s core hosting functionality). We might allow manual backup trigger as well. The integration ensures that when a user clicks restore, we call 10Web and possibly show status while restore is in progress.
Performance & Cache: 10Web likely provides endpoints for clearing cache or adjusting PHP settings (as indicated by tags like Cache, PHP in the API spec). We can expose a simple “Clear Cache” button calling /v1/cache/{siteId}/purge if needed, available to the user.
Monitoring Domain Status: After a custom domain is added, we may poll GET /v1/hosting/websites/{id}/domain-name to see if domain_pointed is true (i.e., DNS propagated) and then call SSL issuance if not already done (though we do it immediately, it might also require domain to resolve first). We present domain connection status in the UI (“DNS verification pending” -> “Domain active”).
White-labeling: All calls to 10Web use an API key that is tied to our master account, and any emails or admin interfaces from 10Web to the user are white-labeled with our branding. We ensure the user never needs to log in to 10Web directly; everything is proxied through our app or handled via autologin links.
The 10Web API integration is critical for delivering the “website in minutes” experience. We handle errors gracefully: if site provisioning fails, we report it to the user and possibly retry or direct them to support. If domain connection fails (DNS issues), we guide the user on how to fix DNS or allow them to retry verification. The tight integration effectively makes 10Web the hosting backend while Naveeg provides the SaaS front-end and additional features on top.
n8n Workflows and Automation
We incorporate n8n, a node-based automation tool, to handle various background tasks and integrations that are easier to maintain visually or require third-party actions outside our core application logic:
Post-Site-Creation Automation: When a new site is created, instead of baking every step into the Edge Function, we trigger n8n for follow-up tasks. For example, n8n can receive a webhook (from our createWordPressSite function or via Supabase event on websites table) to run a “Onboarding Workflow”. This workflow might install necessary WordPress plugins using WP-CLI (n8n has a SSH or specific WP-CLI integration node), import a template if we have one for the chosen business category, and send a welcome emailto the user with tips on getting started. Offloading these tasks to n8n keeps our Edge Functions lean and allows non-developers to tweak the automation if needed.
Lead Integration: When a new lead is captured in the leads table (via a form on the site), we can have a Database Webhook or a Supabase function call n8n. The n8n workflow can then take that lead data and, for example, add a row to a Google Sheet, or create a contact in a CRM like HubSpot/Zendesk, and send an email notification to the site owner. This provides immediate value to Pro users who want to integrate their site leads with other tools.
Chatbot Processing: Similarly, we could choose to handle the FAQ embedding in n8n as an alternative to a pure code solution. For instance, upon uploading an FAQ file, we could send the file to an n8n webhook which then uses an OpenAI node (if available) or a code node to generate embeddings, then writes back to Supabase. However, this might be more complex than doing it in code, so currently processChatbotTrainingFile is in code. But n8n could still be used for scheduled re-training or monitoring (e.g., if we want to automatically update embeddings when content changes).
Periodic Maintenance: n8n can run scheduled workflows as a cron alternative (if not using Supabase Edge Functions for cron). For example, a daily workflow could trigger the dailyTrialSweeper function (or we do it directly in Supabase cron as described). n8n could also handle things like checking for domain expiration (if we sold domains) or sending a report email of analytics every week to the user.
Emails and Notifications: We might use n8n to send system emails (aside from Stripe which sends billing emails). n8n can be connected to an SMTP or a service like SendGrid. For example, when an invite is sent to a team member, our app can call an n8n webhook with invite details, and n8n sends the actual email with a nicely formatted template. This keeps email logic out of our code and lets us update email content easily.
Integration with External APIs: If a customer wants a custom workflow (like every time they get a lead, they want an SMS sent via Twilio), n8n provides a way to do that without us coding it into the core product. We may eventually expose certain hooks or a small library of recipes in n8n for Pro users.
All n8n workflows are triggered securely. We use either http basic auth on n8n webhooks or long random webhook URLs that are kept secret. We do not expose any direct n8n endpoints to the end-user; the triggers are initiated from our backend. This approach allows a lot of flexibility and future expansion (we can add more automations over time and even allow some user-specific automation toggles).
AI Chatbot and FAQ Embedding Feature
One standout Pro feature is the AI-powered FAQ chatbot. This allows a site owner to provide a knowledge base (FAQs, product info) that powers a chat widget on their site, so visitors can ask questions and get answers 24/7. Here’s how it works:
FAQ Content Input: The site owner (admin or editor) can upload a document (PDF, Word, text) containing FAQs or other informational content. Alternatively, they might fill in a structured form with Q&A pairs in the dashboard. This is done in the dashboard’s “AI Assistant” section.
Processing and Embedding: When a new FAQ document is uploaded, the processChatbotTrainingFile Edge Function is invoked (via a Supabase Storage trigger or an explicit call after upload). The function reads the file’s text. It then breaks the text into smaller chunks (for example, each question-answer pair, or paragraphs) to prepare for embedding. Using OpenAI’s Embeddings API (e.g., the text-embedding-ada-002 model), it generates a vector representation for each chunk. These vectors are stored in the faq_docs.embedding column (which might be a vector type if using pgvector, or a JSON array). We also store the plain text content or a reference to the chunk. We mark the faq_docs entry as processed (status = complete).
Chatbot Query Handling: The WordPress site gets a small script (either auto-inserted by us via a WP plugin or provided for the user to add) that creates a chat bubble UI. When a visitor asks a question in the chat, the front-end script sends the question to a Naveeg backend endpoint (likely another Edge Function, say askQuestion or reuse processChatbotTrainingFile with a different route). That function takes the question, generates an embedding for the question (using the same embedding model), and then performs a vector similarity searchagainst the stored FAQ embeddings for that site. This can be done efficiently with pgvector (finding the closest vectors) or by pulling embeddings and computing cosine similarity. It finds the top relevant Q&A entries.
Generating Answer: With the relevant FAQ content retrieved, the function can do one of two things:
Use a simple approach – return the answer text from the closest FAQ entry (if the FAQ was in Q&A format and question matches one of them exactly).
Use a more advanced approach – formulate a prompt for OpenAI’s GPT-4 (or 3.5) that says: “Using the following information, answer the user’s question: [insert the text of the top 1-3 relevant FAQ entries]. Question: [user’s question]”. Then get a completion from the model. This yields a more conversational answer that can synthesize info if multiple pieces are relevant. This approach is common for building QA bots on documentation.
We will likely implement the second approach for better answers. The OpenAI API key for these requests is stored server-side, and we can impose limits (e.g., only Pro plan can call this and maybe with a fair use limit of queries).
Response to User: The Edge Function returns the answer (and maybe some confidence or sources info) to the front-end script, which then displays it in the chat bubble UI as the bot’s response. All of this happens nearly real-time (a couple seconds for the OpenAI API).
UI Integration: In the dashboard, the admin can see a list of their uploaded FAQ documents, with status. They can add or remove content. We might also allow manual input of Q&A directly on the platform, which would just create faq_docs entries without needing a file. We provide an “Embed Code” snippet if needed, but if we control the site (WP) we might auto-insert the necessary script tag into the site’s footer. The chat widget is branded as the site’s assistant (perhaps nameable by the user).
Access Control & Limits: This feature is Pro-only (entitlement chatbot must be true). If a Starter user somehow attempts to call the function, it will reject it. The vector storage and OpenAI calls have a cost, so we monitor usage. We might limit the size of uploads or the number of questions per month in the future (not in initial spec, but something to watch).
Privacy: The content the user uploads stays in their database schema (we don’t share it elsewhere except to send to OpenAI for embedding, which is covered under OpenAI’s data policies). We should mention in terms that they shouldn’t upload sensitive personal data. Also, ensure we abide by GDPR for any data in these docs.
This AI assistant gives small businesses an easy way to offer automated Q&A on their site without complex setup, leveraging AI to interpret user questions and fetch answers from their own content.
User Roles and Permissions (Admin vs Editor)
Naveeg supports collaborative site management through two roles: Admin and Editor. Roles are assigned per website (not global roles), via the team_members table:
Admin: Typically the site creator or owner. Admins have full control over the website’s settings and subscription. They can edit all content just like editors, and in addition:
Upgrade or downgrade the plan (trigger billing flows).
Invite team members (send invites for editors) and remove them.
Manage domains (connect or purchase custom domain) and other integrations.
Delete the site or initiate site deletion if needed.
Essentially, admins can access all sections of the dashboard including billing and team management.
Editor: Intended for team members who help manage content. Editors can:
Log into the dashboard for that site and use the site builder (create/edit pages, adjust design).
Upload media and files (images, documents) to the site library.
Publish and edit blog posts or products (if e-commerce is enabled by plan).
View analytics and leads captured on the site.
Use the AI chatbot content features (if Pro; likely editors should be allowed to update FAQs as it’s content).
Editors cannot change the subscription or billing info, cannot invite other team members, and cannot connect domains or delete the site. Those sections of the UI will be hidden for them. Essentially, they have a subset of admin capabilities focusing on content and analysis, not critical settings.
Only Pro plan sites can have more than one user. During the free trial, we allow invites (since trial has all features of Pro). If a trial expires without upgrading, and editors had been invited, we have a product decision: either allow those editors to continue accessing (Starter with team might not be officially allowed) or temporarily suspend editor access until the site is upgraded. A simple approach is to require upgrade for multi-user support, meaning if a site is on Starter and had editors invited during trial, we might revoke or disable those accounts until upgrade (or inform the admin they need Pro to continue team collaboration). This scenario will be clearly communicated to avoid surprises.
From an implementation perspective, Supabase Auth doesn’t inherently know about these roles, it just knows users. Our application and RLS policies enforce the roles. When an editor logs in, they get the same JWT but the app can fetch their role (e.g., by checking team_members for that site) and adjust UI. The backend RLS will outright prevent an editor from performing admin-only operations as described earlier.
Additionally, there might be a concept of a platform admin (for our internal team) – not a role stored in team_members but either a separate flag in users or using Supabase’s service role outside of user context. Platform admins could, for instance, access any site’s data for support or moderate content. This is not user-facing but important for our internal maintenance (we might implement this later via a special JWT claim or just direct DB access).
Environment Configuration and Secrets
Proper configuration is required for different environments (development, staging, production) to ensure all services connect correctly:
Environment Variables: We maintain a set of environment variables for both the Next.js apps and the Supabase functions:
Supabase Config: NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY are provided to the Next.js apps (both marketing and dashboard) to initialize the Supabase client for user authentication and data fetches (the marketing site might only use it for a contact form, while the dashboard uses it extensively). In Supabase Edge Functions, we use the SUPABASE_URL and a SUPABASE_SERVICE_ROLE_KEY (or the internal SUPABASE_SERVICE_KEY) to allow server-side calls with full permissions when needed (e.g., inside webhooks to override RLS and update tables). These keys are kept secret and not exposed to clients.
Stripe Keys: We set STRIPE_SECRET_KEY (the private API key for Stripe), STRIPE_WEBHOOK_SECRET (to verify webhooks), and perhaps NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY (for client use, if we ever embed Stripe Elements or so, though currently we redirect to Checkout so it might not be needed). We also configure product/price IDs. These can be either stored in the database (the plans table has stripe_price_id) or as env vars. We will seed the plans table with the correct IDs, but in some config we might include them for reference. If using multiple price options (like monthly vs yearly), we would include those as well.
10Web API Key: 10Web provides an API key for our account. This is stored as TENWEB_API_KEY (and possibly TENWEB_API_URL if pointing to their API endpoint, default https://api.10web.io). Only server-side code (Supabase functions) will use this key to make requests. We do not expose it on the client.
OpenAI API Key: OPENAI_API_KEY for using OpenAI services (embeddings and chat completions). This is used in the processChatbotTrainingFile and any question-answer functions. Kept on the server side (Supabase function env).
Google OAuth Credentials: For integrating Google services, we register our app with Google. Supabase can handle OAuth for Google login (for user auth) with its own client ID/secret configured in the Supabase dashboard. Additionally, for Google API integration (Analytics, etc.), we might use a service account for some tasks or OAuth tokens per user. We store the OAuth client ID/secret in Supabase (or Vercel) as GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET for the login, and we ensure the redirect URIs include our domain (app.naveeg.com and possibly localhost for dev).
n8n Webhook URLs: If we trigger n8n via webhooks, the URLs (which contain secret tokens) can be stored as env vars or in the database. For example, N8N_POST_PROVISION_WEBHOOK_URL, N8N_LEAD_WEBHOOK_URL, etc., corresponding to different workflows. These would be invoked by edge functions or directly by Supabase (via HTTP requests). We may also store an n8n API credential if we decide to call n8n’s API to trigger workflows (less likely; webhooks are simpler).
JWT Secrets: Supabase issues JWTs for auth. Supabase manages the signing key internally, but if we needed to verify JWTs outside of Supabase, we would use the SUPABASE_JWT_SECRET. Usually, the Supabase client takes care of auth so we rarely need to manually verify tokens in our Next.js app or functions (Supabase functions automatically get the decoded JWT). However, for security, we might set up a NEXT_PUBLIC_JWT_ALGO and ensure tokens use the appropriate algorithm.
App URLs and Domain Settings: We set variables for our application URLs for emails or redirects. For instance, APP_URL = "https://app.naveeg.com" and MARKETING_URL = "https://naveeg.com". These might be used in emails (like invite links or password reset links) if not using Supabase’s built-in emails. Also, since we have a separate marketing app, if it needs to link to the app, it can use the APP_URL env to construct links.
Region and Localization: If any service requires region specification (10Web site creation uses region code, which we hardcode as europe-west3 in the API call), we keep that value in config or code. Also, for OpenAI or others, if we needed to specify region or endpoint, those would be config.
Vercel Configuration: Each Vercel project (marketing and dashboard) will have its own set of env vars. The marketing site likely needs only minimal ones (Supabase anon, maybe marketing-specific things like an API key for a contact form service if used). The dashboard gets the full set (Supabase anon, Stripe publishable key, perhaps domain settings). We must ensure not to expose secrets in NEXT_PUBLIC prefixed variables. Only public keys or URLs should be NEXT_PUBLIC_* so they end up in the client bundle. Secrets like Stripe secret, 10Web key, etc., should only be used in server-side code (for Next.js, that means in API routes or getServerSideProps if needed; however, we offload most server work to Supabase, so the Next.js app might not need those secrets at all).
Supabase Environment: The Supabase project has its own configuration:
We set up the OAuth for Google in Supabase Auth settings (client ID/secret as mentioned).
We enable RLS on tables and create the policies via SQL (these can be part of our migration files).
We deploy Edge Functions through the Supabase CLI or Studio. The environment variables for functions (Stripe keys, 10Web, etc.) are configured using supabase secrets set ... so they are available at runtime.
Supabase also might need the Stripe webhook secret if we directly call a function endpoint for webhooks (we likely use a Vercel function or Supabase function for webhook; we chose Supabase function for uniformity).
Domains and DNS:
We configure DNS such that naveeg.com (and www) point to Vercel (marketing), app.naveeg.com points to Vercel (dashboard).
We have a wildcard *.naveeg.online pointing to 10Web’s servers (likely a CNAME to something like proxy.10web.cloud or an A record as instructed by 10Web). This allows any generated subdomain to work automatically. 10Web’s domain attach will verify using this.
If we allow custom domains and domain purchase, we might also have to manage DNS zones. Possibly 10Web handles DNS for attached domains via their nameservers or we instruct users to update A/CNAME records. This detail would depend on 10Web’s domain integration. We’ll assume the user points their domain to 10Web (e.g., by setting an A record to a 10Web IP) and 10Web detects when it’s correct.
Development vs Production: In development, we use a local Supabase instance or the provided dev URL and anon key. Alternatively, we use the production Supabase but with a NEXT_PUBLIC_SUPABASE_URL pointing to a dev instance. We will have separate Stripe test keys, a test 10Web workspace (if possible), and perhaps a DEV_TENWEB_API_KEY. We also might use a different domain in dev (like localhost:3000 for app, and some test domain or just local for trial sites – 10Web can’t use .naveeg.online locally, so we might skip actual domain attach in dev or use a dev subdomain like dev.naveeg.online pointing to a test 10Web environment).
By carefully managing these configurations and documenting them in an .env.example, we ensure any new developer or environment can be set up with minimal hassle, and secrets remain out of the repo.
Internationalization Strategy
While the initial launch is English-only, Naveeg’s architecture is prepared for internationalization (i18n) to support multiple languages such as French, Spanish, Italian, Portuguese, etc.. Key aspects of the i18n strategy:
Next.js i18n Routing: We configure Next.js with multiple locales in next.config.js. English (en) is the default, and other locales (fr, es, it, pt) are defined. This setup allows automatic route prefixing (e.g., navigating to /fr/dashboard would show the French version of the dashboard if locales are enabled). We might not initially expose a language switcher until translations are ready, but the plumbing will be in place.
Localized Strings: All user-facing text is stored externally in JSON or similar files per language, or using a library (like i18next or react-intl). For example, we maintain en.json with keys and English translations, and fr.json for French, etc.. The components will load strings from these files based on current locale. We avoid hard-coded text in the React components; instead everything goes through a translation function. This covers both the marketing site and the dashboard.
Date/Number Formats: We utilize locale-specific formatting for dates, numbers, and currency as needed. E.g., showing dates in the user’s locale format. This is usually handled via libraries or built-in Intl APIs.
Right-to-left (RTL) support: Not immediately needed (no RTL languages listed), but if expanding to languages like Arabic or Hebrew, the Tailwind and UI library should accommodate RTL. We’d ensure our CSS can handle it (Tailwind has RTL variants if configured).
Content Localization: For the marketing site, we’ll eventually translate static content (home page text, etc.) into the supported languages. For dynamic content (like user-entered site name or leads), we generally display as-is but the surrounding UI chrome will be translated.
Backend Considerations: The Supabase content (like what users input for their site or their own content) remains user-defined and is not translated by our system. However, if we ever store template content (like default page templates in multiple languages), we would have to handle that. For now, templates (if any) for site generation might only be in English or manually localized.
Default and Fallback: The default locale is English. If a translation for a string or a certain language is missing, we fall back to English. This way partial translations won’t break the app.
Locale Selection: Initially, we might rely on browser language detection or a subpath in the URL to choose language (Next.js can automatically detect and redirect if configured). Eventually, a user-facing toggle could be provided. We’ll also consider email localization (any emails we send could be in the user’s language if we collect that preference).
Internalization of Data (Optional): If we consider multi-lingual content within the user’s website, that might be handled by WordPress itself (since WordPress has plugins for multi-language sites). That is beyond our initial scope – we focus on localizing our own platform UI.
By building with i18n from the start, we ensure that expanding to new markets is mostly a matter of adding translations, rather than refactoring code. This affects the development (developers must wrap texts with translation function and avoid hard-coded strings), which we enforce through code review.
Compliance (GDPR, Data Protection, and VAT)
Compliance is a first-class concern given our target market (EU SMEs):
GDPR & Data Residency: All user data and site hosting is kept within the European Union. We choose the Supabase EU region (likely EU-West or a specific option in Frankfurt) for our database and authentication. Likewise, when creating sites on 10Web, we use the Frankfurt region for hosting to ensure website data (media, etc.) is stored in EU servers. We will sign a Data Processing Agreement (DPA) with Supabase, 10Web, Stripe, and any other processors to ensure GDPR compliance. We also will have a privacy policy stating how user data is used (e.g., we might process their content via OpenAI which could involve US servers, so we’ll mention that explicitly and possibly offer an opt-out for AI features).
White-label / No 3rd-party Branding: Users interact only with Naveeg; 10Web is never exposed. We customize any white-label settings in 10Web so that emails (like WordPress admin emails or backup notifications) come from our domain if possible, or we intercept/replace them. Our platform name is used exclusively to avoid confusion.
Cookies & Tracking: We will implement a cookie consent banner on the marketing site if we use any tracking (Google Analytics for our marketing site, etc.) and ensure no cookies are set in the app beyond those necessary for functionality (Supabase auth uses a JWT in local storage rather than cookies by default, which simplifies cookie handling). If we integrate analytics for user websites, those are under the user’s control (e.g., if they add GA4, they should handle cookie consent on their site, though we might help by providing a banner solution).
VAT and Invoicing: Because prices are VAT-inclusive, we make this clear on all pricing pages (“49 € per month (VAT included)”). We configure Stripe tax settings appropriately. For instance, we might set Stripe’s tax behavior to “inclusive” for EU countries at a fixed rate or include a Stripe Tax feature. Since the price is flat, we might not need to calculate variable VAT – but we should ensure Stripe’s invoices still show VAT for business customers who need to reclaim it. Possibly we will incorporate Stripe’s automatic tax to itemize the VAT portion on receipts (Stripe can determine location via billing address).
We also consider collecting the customer’s VAT ID if they are a business (for B2B zero-rated VAT transactions). However, given our pricing is small and likely targeting small businesses (who usually pay the gross price), we might not handle that initially.
All customers get receipts via Stripe (which are valid invoices including our company info and VAT if configured). We ensure our Stripe account has our business address and VAT number so that it appears on invoices.
Terms of Service and Privacy Policy: The marketing site will have pages for these, outlining trial terms, data usage, etc. We include information such as “By using the trial, you agree that your website and data will be hosted on our cloud infrastructure. After trial, if not upgraded, your site may be restricted or removed.”
Data Deletion: Users (especially EU individuals) have the right to delete their data. We will implement a site deletion process for admins. Deleting a site will remove the WordPress instance from 10Web (via their delete API) and scrub most data from our DB after a grace period. Deleting a user account (if we allow that independently) would remove their personal data as well. We have to coordinate account deletion carefully if the user still has active subscriptions or sites (likely we force them to delete sites first or contact support).
Security: We follow best practices like using HTTPS everywhere (Vercel and 10Web provide SSL). We store passwords only via Supabase Auth (which handles hashing and salts). We don’t store any payment info on our side (Stripe handles that). API keys and secrets are kept server-side. We will undergo routine checks or use Supabase’s monitoring for unusual activity. Additionally, 10Web’s platform presumably has its own security measures (firewalls, DDoS protection, etc. for the WP sites).
Backups of Data: Supabase automatically backs up the database; 10Web backs up the WordPress sites. We ensure that if a user accidentally deletes something, we have some ability to recover (within a time window). At least for WordPress content, the user can use the backup restore. For our own metadata DB, we rely on Supabase point-in-time recovery if needed.
By addressing these compliance issues early, we aim for a smooth operation in EU markets and build trust with users that their data and legal obligations are handled properly.

Prompt to Cursor:
Build a monorepo SaaS product named "Naveeg" with the following structure:
/apps/marketing: Next.js app for the marketing site, deployed on Vercel under the root domain (e.g. naveeg.com).
/apps/dashboard: Next.js app for the user dashboard, behind auth (e.g. app.naveeg.com).
/packages/ui: shared design system using Tailwind + shadcn/ui.
/packages/lib: shared TypeScript utilities for Supabase, Stripe, and 10Web API.
Focus initially on:
Auth (Supabase email/password + Google OAuth).
Onboarding flow: create site on 10Web (trial), set up subdomain, provision default template.
Dashboard shell: navbar with plan badge, domain card, upgrade CTA if on trial.
Stripe integration: Starter and Pro plans (via hosted checkout), webhooks to compute entitlements.
Custom domain form with gating (Pro or Starter only, trial disallowed).
Include all necessary env config examples, RLS policies, and Supabase schema seeds. Ensure production-ready structure with future support for internationalization and n8n workflow triggers.