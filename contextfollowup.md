Naveeg SaaS Launch Roadmap & Checklist
Step-by-Step Launch Checklist
Supabase Database Initialization & Migrations:
Install and configure the Supabase CLI. Log in (supabase login) and link the CLI to your Supabase project (using your project ref). This creates a supabase/config.toml with the project details.
Run supabase db push to apply all local database migrations to the remote database
supabase.com
. This will create the schema and tables in your Supabase project. Define the initial schema if not done already (e.g. tables for users, websites, plans, etc.).
Seed initial data: for example, insert subscription plans into a plans table (Free Trial – 7 days, Starter – €49/mo, Pro – €99/mo). Ensure the Starter plan price is set to €49 (not €29) in this seed data.
Set up Row-Level Security (RLS) policies on the new tables to enforce tenant isolation (so users can only access their own data). Enable RLS and write policies for each table (at least for users and websites) before going live.
Verify Supabase Auth is configured: enable email/password sign-up and Google OAuth in the Supabase dashboard (if you haven’t). Ensure your redirect URLs for OAuth include the production domain. Test that a user can register and that a corresponding record appears in your users table (this may be via a trigger or a direct insert in your implementation).
Gather all Supabase project keys: Project URL, anon key (for frontend), service role key (for backend calls). These will be needed in your applications (the anon key in client-side code, service key in backend environments). Do not expose the service key in the frontend.
Stripe Configuration & Webhooks:
In Stripe, confirm your products and prices are set up correctly for the Starter (€49/month) and Pro (€99/month) plans. Adjust the pricing in Stripe if necessary to match these amounts (the Starter plan was intended to be €49, so update it from €29) and retrieve the updated Price IDs. Use Stripe test mode for now to avoid real charges.
Update your application’s configuration to use the correct Stripe Price IDs for Starter and Pro. For example, if you store them in environment variables or a config file, put the new IDs that correspond to €49 and €99. This ensures that when users upgrade, they are directed to the right plan in Stripe. Also update any displayed pricing on your marketing site to €49 for Starter.
Implement the Stripe Checkout integration in your app: when a user chooses to upgrade, create a Stripe Checkout Session using the Stripe SDK or API. Include metadata in the session (such as the Supabase user_id or website_id) so you can identify the customer/session in the webhook handler. Set the success URL (perhaps a dashboard page that shows upgrade success) and cancel URL (back to the pricing page).
Configure a Stripe webhook endpoint to receive events. In Stripe’s dashboard, add a webhook URL that points to your backend (e.g. a Next.js API route like /api/stripe-webhook or a Supabase Edge Function endpoint) and subscribe to relevant events (at minimum: checkout.session.completed, and also invoice.payment_succeeded, customer.subscription.updated, customer.subscription.deleted for recurring payments or cancellations). In your code, secure this endpoint by verifying the Stripe signing secret for each event received. Store the webhook secret in your environment variables so the code can use it for signature verification.
In the webhook handler code, implement logic for these events: for example, on checkout.session.completed, find the user or site that corresponds to the session (using the metadata or the Stripe customer ID) and update your Supabase database to mark their plan as Starter or Pro (update the plan_id or similar in the websites table). Save the Stripe customer_id and subscription_id in a subscriptions table or the websites table so you can track the subscription. For invoice.payment_succeeded (renewal payments), you might extend their next billing date or just log the event. For customer.subscription.deleted (cancellations), mark the user's plan to downgrade at period end or end the subscription immediately, depending on your policy.
Test the webhook integration using Stripe’s CLI or dashboard: run a test Checkout in test mode, let it redirect to your success page, and verify that Stripe sends a checkout.session.completed event to your webhook. Check your application logs or database to ensure the event was processed (the user’s plan should now be updated in Supabase). Adjust the code as needed if the webhook is not working.
Before go-live: switch Stripe to live mode. Replace your Stripe test API keys with the live keys in your production environment, and update the product IDs if they differ in live mode. Add a live-mode webhook endpoint in Stripe with the live signing secret. It’s a good idea to do a final test with Stripe’s test card in live mode or a real €0.50 product to ensure everything works, then refund/cancel as needed.
10Web API Integration:
Make sure you have your 10Web API access token and any required credentials. Test the API separately (using a tool like curl or Postman) to ensure the token works and you can hit a simple endpoint. For example, test a GET on a 10Web endpoint or list current sites to verify connectivity.
Implement the backend function to provision a new WordPress site via 10Web. This could be a Supabase Edge Function or a Next.js API route. Using the 10Web API, call the endpoint to create a website (e.g. POST /v1/hosting/website) with the necessary data like site title and region. 10Web will respond with a website_id for the new site. Next, call the endpoint to add a domain for that site (e.g. POST /v1/hosting/websites/{website_id}/domain-name) to attach a subdomain on your white-label domain (like user123.naveeg.online). Then call the endpoint to make that domain default and request SSL for it (often .../domain-name/{domain_id}/default and an SSL trigger). These steps ensure the site is accessible at *.naveeg.online with HTTPS.
In your database, insert a record into the websites (or equivalent) table for the new site when creation is successful. Include the 10Web website_id, the chosen subdomain, the plan (likely “trial” by default), the owner_id (user who created it), start of trial timestamp, etc.. This keeps your backend in sync with 10Web’s provisioning.
If possible, implement error handling for site creation. For example, if the 10Web API call fails or the subdomain is already taken, ensure your function returns an error to the frontend so the user can be notified (and they can try a different subdomain if that was the issue). Gracefully handle timeouts or 10Web errors so that a failure doesn’t crash your app.
Webhook from 10Web (optional): Check if 10Web can send webhooks for events like site creation completed, site ready, or backups. These are nice-to-have for monitoring. If available, set up an endpoint to receive those (e.g., a Supabase function or n8n webhook) and log an event or update site status (for instance, mark in your DB when the AI content generation on 10Web is finished). This isn’t critical for launch, but it can help you track things in the background.
Set up the wildcard domain DNS for your trial sites. In your DNS provider for naveeg.online, create a wildcard A record or CNAME: e.g., *.naveeg.online pointing to the IP or hostname that 10Web specifies for site mapping. (10Web’s documentation or support should provide the exact value; it might be an IP address to point A records to.) This will ensure any subdomain under naveeg.online will resolve to 10Web’s servers. Once set, verify it: for instance, if you created a test site demo.naveeg.online, try opening it in a browser to see if it resolves. You should get at least a placeholder or the WordPress site (and after a minute or so, a valid SSL certificate as 10Web provisions it). Important: do this well before launch because DNS propagation can take some time (though a wildcard record should propagate within a couple of hours typically).
Confirm on the 10Web dashboard that your white-label domain is recognized and that SSL is working for the subdomains. You might need to configure the domain in 10Web’s interface (adding naveeg.online as a custom domain in your 10Web reseller settings). After configuration, any site you create via the API with a *.naveeg.online domain should be live and secure.
Frontend Deployment on Vercel:
Create two projects in Vercel, one for each Next.js app in your monorepo. For example, naveeg-marketing (connected to the /apps/marketing folder) and naveeg-dashboard (connected to /apps/dashboard). Vercel supports monorepo detection; make sure to specify the root directory for each project and the build commands if not auto-detected.
Add environment variables to each Vercel project. For the marketing site, you’ll likely need the Supabase URL and anon key (for any client-side calls, like a contact form submission) and perhaps the Stripe publishable key if you embed any Stripe elements (in a pricing section, for example). The marketing site should not have any secret keys. For the dashboard app, include Supabase URL and anon key as well, plus any secrets needed on the server side: e.g., Supabase service role key (if your API routes call Supabase as admin), Stripe secret key, Stripe webhook secret, 10Web API token, and any other third-party secrets. These should be set as environment variables (and on Vercel you’d mark them as “Encrypt” which is default) so they are available to your Next.js API routes or Supabase functions at runtime. (Remember to also configure these in the local dev .env for testing.)
In Vercel, configure the custom domains for each project. For the marketing project, add naveeg.com (and perhaps also configure www.naveeg.com to redirect or alias to naveeg.com). For the dashboard project, add app.naveeg.com. Vercel will provide verification tokens or CNAME records that you need to add to your DNS provider for these domains. Do that verification step promptly. Once verified, Vercel will provision SSL certificates for those domains automatically.
Update DNS for your main domain: in your DNS provider for naveeg.com, add the records as instructed by Vercel (likely two A records for Vercel’s IPs, or an Alias/ANAME, or a CNAME to a Vercel subdomain). For app.naveeg.com, add a CNAME to the provided Vercel subdomain (e.g., cname.vercel-dns.com.). Ensure that www.naveeg.com is also covered (either by a CNAME to naveeg.com or as its own record in Vercel) so that users typing www don’t get an error.
Perform a test deployment. For example, push your code to a staging branch or use Vercel’s preview deployments to ensure everything builds correctly. Vercel will deploy the marketing and dashboard apps. Check the preview URLs (e.g., naveeg-marketing.vercel.app and naveeg-dashboard.vercel.app) to verify that the sites load. If there are build errors or runtime errors (environment issues, etc.), address them now. Common issues could be missing env vars or build commands. Make sure both apps are building successfully in the Vercel environment.
Pre-Launch Data & Configuration Fixes:
Double-check all places where the Starter plan price might be referenced. This includes marketing copy, pricing page, and any default data in the app. Update every instance of “€29” to “€49” to avoid confusion at launch (the database seed was set to €49 as per the plan, so ensure the frontend reflects that as well). Verify that the Stripe Price ID configured for Starter corresponds to €49 – if a new price ID was created in Stripe, update your env var or config for Starter plan ID.
Ensure that all secrets and config variables are correctly set in production configs. It’s easy to have a typo in an environment variable name that only becomes apparent on deployment. For instance, if your Supabase URL or key is wrong, the frontend will fail to fetch data. Compare your local .env with Vercel’s settings and the Supabase project settings. Particularly, check the Supabase anon key matches the project you intend to use for production (if you tested with a dev Supabase project, you’ll want to switch to the prod project’s anon key). Also confirm the Supabase service_role key is correct in the backend env (for serverless functions).
If you have any test data or accounts in your production Supabase project from earlier testing, consider cleaning them up before launch. For example, if you have a test user account or a test “Hello World” site in the websites table, you might delete those to start fresh. Alternatively, you can keep one admin/test account for yourself but plan to remove any dummy sites or clearly mark them. This ensures that real users see zero existing content (especially if any test data might appear in a listing or leaderboard by accident).
In Supabase, ensure email templates for sign-ups (confirmation emails, etc.) are configured with your branding (you can do minimal changes or leave default for now, but no harm in checking). Also set up the JWT expiration and other auth settings as desired (the defaults are usually fine).
If your application uses any feature flags or config files (for example, a JSON defining plan features, trial length, etc.), verify those are up to date with final decisions. For instance, if trial is 7 days, make sure it’s 7 everywhere and that the code that checks trial expiration is using the correct date field. Small consistency issues can be confusing to users (e.g., one page saying 14-day trial while another says 7).
Contact Form & Newsletter Setup:
Set up a Contact Us form on the marketing site. Choose an implementation method:
Using Supabase: Create a new table (for example, contact_messages) with fields for name, email, subject, and message, or simply a JSON field for the message. Enable insert permissions for anon users either via a Row Level Security policy or a stored procedure called by a Supabase Edge Function (to validate and then insert). A simpler approach is to create a Supabase Edge Function that you call from the frontend (so the secret keys stay server-side) which inserts the message into the DB.
Using an external service: If time is short, use something like Formspree or Zapier Email Parser. For example, Formspree can handle form submissions without a backend – you just point the form action to Formspree and it will email you the submissions. This avoids needing to set up RLS rules.
Whichever method you choose, test the contact form thoroughly. Submit a message and ensure that: (a) you see the data stored in the database or you receive an email notification, and (b) the user gets a confirmation on the site that their message was received. It’s good to implement a quick success message on the form submission. If possible, set up an autoresponder: for instance, if you go with Supabase, you could use an automation (like an n8n workflow or Zapier) that triggers on new contact_messages rows and sends an email back to the user saying “Thanks, we’ll be in touch”. This gives users immediate reassurance.
Add a newsletter signup form to capture leads who aren’t ready to start a trial. This could be a simple email input in the footer or a dedicated section saying “Stay updated”. Connect this form to either:
A Supabase table (e.g., newsletter_leads with just an email field). You can use the Supabase JS client on the frontend to insert the email into this table (open it for insert for anon, or again use a secured function).
Or use an external newsletter service’s form. For instance, Mailchimp provides embed code for a newsletter signup form that you can drop in – it will handle double opt-in and storage of emails. ConvertKit or others have similar forms. The docs suggested using either Supabase or an external service for this, so choose what fits your timeline.
Make sure to include a brief note about privacy when collecting emails, especially for EU compliance. For example, add a sentence like “By subscribing, you agree to receive our newsletter. You can unsubscribe at any time.” or a checkbox for consent if required. While a single checkbox might not be strictly required for a simple newsletter (consent can be implied by the voluntary signup), it’s good to clarify how you will use their email.
Test the newsletter form by submitting a couple of email addresses (you can use a+alias on your Gmail to simulate different emails). Verify these emails appear in the Supabase table or the external service list. Also test the double opt-in if your external service sends a confirmation email.
Ensure that you have Privacy Policy and Terms of Service pages created and linked on your site (commonly in the footer). You can use generated templates for launch (there are many free generators for basic terms and privacy). This is important for legal compliance and building trust with users who will be providing personal info. Similarly, have a visible link to the Contact page or an email address so users can reach support easily.
Quality Assurance (QA) and Testing:
Before launching, perform a comprehensive end-to-end test of the entire user journey in a staging environment or using the production setup with test credentials. This means starting from a brand new user and exercising all main features:
Sign-Up: Create a new account via email/password. Ensure no errors occur and that a new user row is created in the database (if you have a users table separate from auth). If email confirmation is required, check that the email arrives (perhaps using a test email account). Also test sign-up or login with Google OAuth to confirm that flow (Supabase makes this relatively straightforward, but the redirect URI must match your domain).
Onboarding & Site Creation: After signing in, go through the process of creating a WordPress site. Enter the required details and submit. The app should call the 10Web integration and provision a site. Monitor that this completes without errors: the new site should appear in the dashboard UI, and you should be able to navigate to the site’s URL (e.g. your-site.naveeg.online) to see the WordPress site live. In Supabase, verify that the websites table (or relevant tables) have the correct data for this site (owner id, plan = trial, etc.).
Upgrade to Paid Plan: Still as the test user, go through the upgrade flow. Click the upgrade button, select the Starter plan, and complete the Stripe checkout using test card info. Ensure that Stripe redirects back to your app (or wherever you configured). After a minute (to allow the webhook to fire), verify the app now recognizes the user as paid. For example, the dashboard might no longer show “Upgrade” and might show the plan as Starter. In the database, check that the site’s plan was updated to Starter and that a Stripe customer and subscription ID are recorded. If you have any Pro-only features, you can also test upgrading to Pro similarly.
Cancellation/Downgrade: Although you may not fully implement cancellations in the UI yet, simulate one if possible. For instance, use the Stripe dashboard to cancel the test subscription and then trigger the webhook (Stripe sends customer.subscription.deleted). Ensure your webhook handler would mark the subscription as canceled/downgrade the user’s plan appropriately. You might see the site still active until trial or billing period ends (depending on your intended logic). It’s okay if the app doesn’t immediately reflect cancellation (as long as no billing occurs), but take note to handle this eventually.
General UI/UX: Test navigation and state: log out and log back in to see that session persistence works. Test the password reset flow if you have one (Supabase can send a magic link — try triggering it and completing a password reset). Make sure protected routes indeed require login (try accessing the dashboard URL while logged out, it should redirect to login).
Error Handling: Intentionally cause small errors to verify the app handles them. For example, try creating a site with a subdomain that you’ve already used in a previous test (the 10Web API might return an error for duplicate subdomain). The app should ideally catch that and prompt the user to choose a different name, rather than just spinning or crashing. Also, stop the network or put the browser offline briefly after clicking “Create site” to simulate a network error, and see if the app shows an appropriate error message. The goal is to ensure no major user action just fails silently or hangs indefinitely.
Perform cross-browser and mobile testing. View the marketing site and dashboard in at least Chrome and Firefox, and on a mobile device or using responsive mode in dev tools. Ensure the layout is mobile-friendly and there are no glaring styling issues or JavaScript errors on different browsers.
Keep a list of any bugs or UX issues encountered during testing and fix them before launch. For example, you might discover that a certain button doesn’t work on Safari or that an element isn’t centered on mobile – these should be relatively quick fixes in CSS or minor logic adjustments. It’s better to catch them now than have real users see them.
If possible, have a friend or colleague do a quick run-through as well (they can use the staging or preview link or you can do a screenshare). A fresh set of eyes might catch things you overlooked, like a confusing wording or a missing piece of info. This “user acceptance testing” step can be invaluable.
Security & Monitoring Setup:
Security Audit: Do a rapid audit of the critical security points:
All API keys and secrets should be hidden on the server side. Search your frontend code for any occurrence of sensitive keys (like 10WEB_API_KEY, STRIPE_SECRET) to ensure none are exposed. The only keys that belong in frontend code are the Supabase anon key and Stripe publishable key.
Verify Row-Level Security is active and properly configured on the database. You can test this by attempting to read data from another user’s perspective. For instance, create a second user account and ensure it cannot query the first user’s data via Supabase (if using Supabase JS client, it should naturally apply RLS; you can also use the psql interface or Supabase Studio to simulate). The RLS policies should allow each user to see their own data and nothing else.
Ensure all web traffic is going over HTTPS. Vercel will default to HTTPS on your custom domains once configured. Just double-check that if someone types http://naveeg.com, it redirects to https:// (Vercel usually handles this redirect). Also verify that any external resources your site loads (fonts, scripts) are using HTTPS URLs to avoid mixed content issues.
Consider setting up security headers. Next.js/Vercel allow setting headers for things like Content Security Policy (CSP), X-XSS-Protection, etc. If you have time, configure a minimal CSP that at least restricts script-src to your domain and trusted sources. If not, plan to add it post-launch.
Monitoring:
Set up an error tracking service such as Sentry for both frontend and backend. In Next.js, you can initialize Sentry in _app.js for frontend errors and also capture API route errors. This will help you catch any runtime exceptions that happen to real users. Sentry offers free plans that are usually sufficient for early-stage.
Utilize Supabase’s monitoring: the Supabase dashboard provides logs for Edge Functions and the database. Make sure you know how to view those. For instance, if a webhook function fails, you should be able to see the error logs in Supabase’s interface.
If you built any part of the backend with Supabase Edge Functions, consider setting up health checks or at least test them in production (Supabase allows invoking them from the dashboard).
Logging: If not using a dedicated service, you can also temporarily add some logging (even console.log that will appear in Vercel function logs or Supabase function logs) around critical areas (like the Stripe webhook handler and 10Web provisioning) just so you have some trace in case something goes wrong for a user at launch. Remove or tone down these logs after initial launch period if they’re too verbose.
Set up basic analytics on the marketing site if not already done. For example, add Google Analytics 4 or a privacy-focused tool like Plausible. This will help you understand user traffic and conversions. Ensure you respect privacy: if using GA4, integrate a cookie consent banner so it only tracks after consent, or use Plausible which doesn’t use cookies and is GDPR-compliant by default.
Support & Feedback Channels:
Prepare a way to quickly respond to user issues. If you set the contact form to email you, have that email monitored on your phone. If using the database to collect messages, check it frequently or build a quick admin view for yourself. Early on, users might just email you directly if you provide an address – that’s fine, just be ready.
If you have an onboarding email sequence (even a single “Welcome to Naveeg” email on sign-up), ensure the content is correct and it doesn’t land in spam. You might send it from a custom domain email (which may require setting up SPF/DKIM records).
Set up a status page or at least be ready to inform users if something goes down. This could be as simple as a Twitter account or a section in your app for announcements, but since it’s early, direct communication with users via email might suffice for any incidents.
Ensure compliance basics are covered: your Privacy Policy page should outline how user data is used and stored (mention the use of Supabase (Postgres in EU), 10Web (hosting in EU), Stripe (for payments), and any analytics or email services). State that by using the service, users agree to these terms. This isn’t a legal consultation, but having these pages in place is important. Also, all user data is kept in the EU to satisfy GDPR data residency concerns, and you have a mechanism to handle user data requests (even if it’s manual, you can honor requests to delete data or export data).
Deployment & Launch:
Final Deployment: Merge your changes into the main branch (or whichever branch triggers production deployment on Vercel). Watch the deployment logs on Vercel for both the marketing and dashboard projects to ensure the build succeeds. If something fails, use the logs to debug (likely environment variables or build issues as mentioned earlier). Once the deployment is live, Vercel will make the sites available at your custom domains.
Production Verification: Immediately perform a few key tests on the production sites:
Visit naveeg.com in a private/incognito window. Check that it loads quickly over HTTPS and the content (especially pricing) is up to date.
Click the sign-up button on the marketing site; it should correctly route you to the app (app.naveeg.com) sign-up page. (If it still points to a localhost or an old URL, update the link!).
On app.naveeg.com, go through the sign-up and site creation flow just as you did in staging. This time you’re hitting the real environment (with real Supabase project, etc.), so confirm it all works end-to-end. Create a trial site and make sure it appears and is accessible.
If you have switched Stripe to live mode, and you’re confident, you can do a real payment test now (perhaps set the price to a very low amount or create a one-time test coupon). Alternatively, keep Stripe in test mode for a few hours during a “soft launch” so you can test with a test card in production. Just remember to switch to live and test again with a real card before fully announcing the launch.
Check that Stripe webhooks are being received on the live URL. In Stripe’s dashboard (Developers > Webhooks), you can see recent attempts. They should show as status 200 OK. If not, there might be an issue with the endpoint (e.g., missing the live webhook secret or the route not deployed). Fix any issues (you can simulate events with Stripe CLI pointing to your live domain if needed).
Test the contact form on the live site and ensure you get the submission. Also test the newsletter form on production and see that it records to the correct place.
DNS and SSL: Do a quick DNS check for your domains. Using a tool like dig or an online DNS checker, confirm that naveeg.com and app.naveeg.com point to Vercel, and that a random subdomain of naveeg.online points to the 10Web IP. Also, open a random test subdomain (or the one you created) in a browser to ensure the SSL certificate is valid. Vercel handles the SSL for your main domains, and 10Web handles it for the subdomains – both should show the lock icon with no warnings.
Performance & Load: With everything live, keep an eye on the app’s performance. The first few visitors might experience cold starts on your serverless functions (Stripe webhooks, site creation function) – monitor those. They should be reasonably quick after the first invocation. If anything is too slow (e.g., site creation taking long), inform the user via UI (maybe a loading state with a message “This may take a minute”).
Monitoring: As users sign up (or as you test), monitor your error tracking and logs in real-time. If an error is caught (say the webhook crashed due to a payload difference in live mode), act immediately to patch it. Vercel allows quick redeploys; you can fix the code and redeploy in minutes. Supabase Edge Functions can also be updated quickly with their CLI. Early in launch, rapid response is key.
Analytics & Metrics: Check your analytics dashboard to see if page views and sign-ups are being recorded. This will validate that tracking is working. Also keep track of key metrics in a simple way: even a Google Sheet where you manually note daily sign-ups, active sites, etc., can help you gauge growth and identify if something’s off (for instance, many visits but zero sign-ups might indicate a broken sign-up flow).
Final Launch Steps: Remove any “coming soon” banners, passwords, or test modes. For example, if you had a flag in code that prevented search engine indexing or required a password to access the site (sometimes done for staging), remove those for production. Ensure the app and marketing site are fully accessible to the public.
Announce Launch: Once you’ve validated everything in production with your own tests and maybe a soft launch to a few users, announce it! Post on your social media, send an email to any signups or friends who were waiting, and consider posting on platforms like Product Hunt or Hacker News (though it’s often good to ensure the platform is stable before a big influx). Be ready to receive feedback and questions. Set up a way to collect this feedback (even as simple as an email or Typeform link for suggestions).
Post-Launch Monitoring: In the first days after launch, keep monitoring closely. Make sure to respond to any user-reported issues quickly – this will likely be via email or Twitter. Also watch your infrastructure: e.g., if a lot of users sign up, make sure you’re not hitting any limits on Supabase (like max row count on the free tier) or on 10Web (number of sites, etc.). It’s better to upgrade a plan or increase a limit proactively than to have the service throttled unexpectedly.
Pre-Launch Testing Flow
Before the official launch, use a staging environment or the production environment in test-mode to verify all user flows. Here’s a recommended testing scenario:
New User Signup: Create a brand new account on the platform. Test this with both Email/Password signup and Google OAuth signup. Verify that the signup process works smoothly – for email signup, check that the user is either auto-logged in or prompted to verify their email (depending on your Supabase settings). In the database, ensure a new user entry is created (in the auth.users and your public users profile table if you have one) with the correct information. If email confirmation is required, use the link sent to actually confirm the account and then log in.
Trial Site Provisioning: After signup (or first login), test the “Create Website” flow. Fill out the site creation form with valid details (site name, any AI options, etc.) and submit. Confirm that the frontend calls your backend (Next.js API or Supabase function) and that a new WordPress site is created via 10Web. You might need to wait 30-60 seconds if content generation is involved. Then:
Check the Supabase database: a new entry in websites (or equivalent) table should exist for this site, tied to your user ID, with a trial plan and a tenweb_id etc.
Check the 10Web dashboard (if accessible) to see that a new site is listed there.
Visit the generated site’s URL (e.g. mysite.naveeg.online). It should load the WordPress site. If the SSL certificate isn’t ready yet and you get a security warning, wait a minute and try again (Let’s Encrypt might be in process). Once it’s ready, the site should be accessible over HTTPS without errors.
Verify the Naveeg dashboard updates: it should now list the new site in the UI, showing perhaps the site name and an indicator that it’s on a trial. Test any provided actions like “View Site” or “Go to WP Admin” links. Those should direct to the correct URLs (the WP Admin link should ideally use the auto-login link if you implemented that, or otherwise just go to wp-admin where you’d use the credentials set by 10Web).
Plan Upgrade (Starter/Pro): While logged in with the trial user, test the upgrade to a paid plan. Click on “Upgrade” or whatever CTA you have for subscribing. In the Stripe Checkout, use the test card information (e.g., 4242 4242 4242 4242 with any future expiration and CVC) to simulate a successful payment. After completing checkout:
Ensure your application reacts appropriately. Ideally, it should detect that the checkout session is complete (either via the webhook or a client-side redirect page). Possibly you show a “Success, your site is upgraded!” message.
In the database, verify that the site’s record now reflects the paid plan (plan changed from trial to Starter/Pro, trial_end set to null or an upgrade date set). The Stripe customer ID and subscription ID should be saved in your system as well.
If your UI offers new features for paid plans, check that those features unlock. For example, if Pro plan allows custom domain, see that the option to add custom domain is now enabled for that site.
Additionally, check Stripe’s dashboard to confirm that the test payment went through and the subscription is active. This ensures the frontend correctly created the session with the right Price ID and the webhook was processed.
Test the scenario where the user cancels during checkout or the checkout fails. For example, click upgrade but then close the Stripe window or use a card number that simulates a failure (Stripe has test cards for decline scenarios). Your app should handle this gracefully (perhaps the user stays on trial and can try again, maybe show a message if Stripe returns an error on the client side).
Cancellation & Renewal: If possible, simulate a subscription renewal and cancellation:
For renewal, you can manually trigger an invoice payment event in Stripe or just note that the system should continue working (this is more for long-term, since in testing you won’t wait a month for renewal).
For cancellation, go to Stripe dashboard’s test mode, find the subscription for your test user, and “Cancel immediately”. This should trigger a customer.subscription.deleted event to your webhook. Confirm your webhook handler processes it (maybe mark the site as cancelled or scheduled for downgrade). In Supabase, the site’s plan might remain as Starter until the period is over, but you could set a flag “cancel_at_period_end”. Just ensure that no immediate errors occur from this event.
If you have implemented the Stripe customer portal for self-service, test launching that from the dashboard (Stripe provides a session link for the customer portal) and see if it works. This step is optional.
Authentication & Authorization: Test logging out and logging back in. Test a password reset (if your app exposes that): using Supabase’s magic link feature is common – trigger a password reset email and go through the flow to set a new password. Ensure after resetting, you can log in with the new password. Also verify that pages that require authentication (like any dashboard route) indeed redirect to login if you are not signed in. Conversely, the marketing pages should be accessible while not logged in. Try accessing the dashboard URL while not logged in – you should be redirected or stopped by the auth guard. Also test that a logged-in user hitting the marketing site and clicking “Login” doesn’t have to log in again (if you share auth state or at least it should detect and redirect them to the dashboard).
Contact Form Submission: On the Contact page of the marketing site, fill in the form with sample data and submit it. Then check the outcome: if it’s using Supabase, go to the database and see if the row is created in contact_messages (and check if any trigger/email was sent). If using an email service, check that you received the email. Verify the user got a success notification. Also test the form’s validation (try submitting without an email or with an invalid email to see if it shows an error). Similarly, test the newsletter signup with a sample email and ensure it gets recorded in whatever system you chose. If double opt-in is enabled (for external services), the test email should receive a confirmation message – check that as well.
Content and Copy Review: Do a thorough pass on all the static content: read every page (Home, Features, Pricing, FAQ, About, Contact, Terms, Privacy). Look for typos, placeholder text, or inconsistent information. Ensure that pricing figures are correct everywhere (no outdated €29 mentions). Make sure the FAQ answers correspond to the actual implemented behavior (for example, if the FAQ says “you can connect your custom domain on a paid plan”, ensure that feature is actually available to test or clearly marked as coming soon). Check that all links in the website (header, footer, within text) work and none lead to 404.
Responsive Design and Browser Testing: Open the marketing site on a mobile device (or use Chrome’s device simulator). Verify that the layout is still user-friendly – text should be readable without zooming, buttons should be tap-friendly, and no elements overflow off the screen. Do the same for the dashboard: while users might predominantly use desktop for a site builder, some might try on mobile or tablet. At least ensure it doesn’t completely break on a smaller screen (even if you don’t optimize fully for mobile dashboard usage now). Additionally, test in a couple of browsers (e.g., Safari and Firefox) to catch any browser-specific issues (especially with CSS or any APIs that might behave differently).
Performance Check: Run a quick performance audit using browser dev tools or Lighthouse on the marketing site. Check for any obvious slow-loading resources or oversized images. Since the marketing pages are mostly static, they should be fast. Also monitor the network requests when performing actions in the dashboard – calls to Supabase or 10Web should not hang unnecessarily. If you see any request taking a long time (several seconds), investigate if it’s expected (e.g., the site provisioning call will take several seconds – maybe show a spinner or progress step to the user).
Backup and Recovery: Although not a “user flow”, consider testing your ability to recover from issues. For example, if you have database migration SQL, ensure you have a way to roll back if needed. Export a backup of your database after seeding the initial data, so you can restore if something catastrophic happens during a migration. Test that you can deploy updates without downtime (Vercel does this seamlessly, but for database changes, you might want to use Supabase migration files carefully). Essentially, be prepared with a plan B if anything goes wrong during launch – even if that plan is as simple as “put up a maintenance page and fix the issue quickly.”
By following this testing flow, you’ll cover the most important aspects of the user experience and catch potential problems before real users do. Document any issues you find and address them before proceeding to the full launch.
Deployment Validation
Once you deploy to the production environment, perform these validation steps to ensure everything is configured correctly:
Domain & SSL Verification: Confirm that your primary domain and subdomain are working as intended. Visit https://naveeg.com and https://app.naveeg.com in a private browser session. Both should load your apps over HTTPS with no certificate errors. Vercel’s SSL should be in place once the domain was added – look for the lock icon in the browser. If you encounter any certificate issues, re-check the domain verification steps on Vercel and that your DNS CNAMEs/A records are correct. Also test the naked domain vs. www (naveeg.com vs. www.naveeg.com) – if you didn’t set up www, ensure it redirects to naveeg.com or add it in Vercel to be safe.
Basic Functionality Smoke Test: Do a quick pass of core functionality on the live site:
Sign up a new user on the live site (you can use a real email or a dummy that you have access to). Ensure the sign-up and email verification (if enabled) works on production.
Log in and create a site (using perhaps a “launch” test subdomain like launchtest.naveeg.online). This will test that the production Supabase and 10Web credentials are all correct and that the live environment can talk to 10Web. If the site creates successfully and appears in your dashboard, that’s a great sign.
If Stripe is live, you might do a live payment test with an actual credit card (perhaps create a one-time €1 product for a quick test, or use the real plan and plan to refund/cancel immediately). This will verify that the live Stripe keys and webhooks are correctly set. If you’re not comfortable charging your card, at least verify that the Stripe Checkout opens with the correct price and that the webhook logs in Stripe show a successful hit (Stripe allows a test mode even with live keys by using specific test card numbers while in test mode Checkout session).
After a site is created, check that you can access it via its subdomain in production (this tests the wildcard DNS in real usage). Also test any secondary actions like inviting team members (if implemented) or uploading content, just to ensure those parts have no environment-specific issues.
Stripe Webhook Delivery: In the Stripe dashboard, go to Developers -> Webhooks and inspect the recent events sent to your production webhook endpoint. They should show as “Succeeded/200 OK”. If you see failures, click on them to see the error and fix the issue (common mistakes are using the wrong signing secret, or the route not found due to a misnamed path). You can also manually trigger a resend from Stripe after fixing. This validation is crucial to ensure that payment events are being received by your app.
Supabase Connectivity: Open the browser console or network tab while using the production app. Watch for any 400/500 errors on API calls to Supabase or your own APIs. Sometimes something like an RLS misconfiguration can cause a request to be denied (403) in production but maybe was open in development. For example, if the marketing site tries to insert a contact message and it fails due to RLS, you’d catch an error in the console. Identify any such issues and resolve them (you might need to tweak policies or function permissions in Supabase). Also ensure the Supabase project’s URL is the correct one (no calls should be going to localhost or a wrong endpoint).
DNS Wildcard Propagation: Verify that the wildcard DNS for naveeg.online is fully propagated. You can use a tool like dig or an online DNS checker. Additionally, create a new trial site on production if possible (or use the one you made) and try to access it from a different network (for example, turn off WiFi and use mobile data, or ask someone in another city to try). This ensures that the DNS resolution and 10Web routing works beyond just your local cached DNS. Since DNS propagation might take some time, doing this validation a few hours after setting the record is wise.
Performance Monitoring: Keep an eye on the response times of your pages and functions in production. Vercel and Supabase are quite scalable, but for instance, the first cold start of a Supabase Function (if you used them) might be slow. After that, it should be fast. Use Vercel’s built-in analytics or Supabase’s function logs to see if any request is taking unusually long. If, say, the Stripe webhook or 10Web function is consistently slow, you might need to optimize it or at least set proper user expectations (loading states). Also, check the size of your pages – ensure that any large images or scripts are properly optimized (Next.js should help here with code splitting and such).
Resource Usage & Quota: Log in to your Supabase dashboard and check the project usage (API requests, storage, etc.) now that you’ve done a few operations. Ensure you’re within free tier limits or your plan limits. Supabase will show if you are close to quota in any area. Similarly, check 10Web (some white-label plans might have limits on number of sites or total storage). For Stripe, see if webhooks are failing due to volume (unlikely at launch scale) or any other limit. This proactive check helps avoid hitting a cap unexpectedly when real users join.
SEO & Metadata: Fetch your website as a search engine would (you can use tools like curl or SEO tools, or just the “Inspect URL” in Google Search Console if you have set that up). Make sure the page titles and meta descriptions are present and appropriate. For example, the <title> tag for your landing page should mention Naveeg and a tagline, not “React App” or something default. Also ensure social sharing metadata (Open Graph tags) are set so that when you or others share naveeg.com on social media, it shows a nice preview with your logo or screenshot.
Final Content Validation: Do one last run-through on production of all text and links (yes, again!). It’s easy to miss something in staging that could be different in prod. For example, if you had any absolute URLs in your code pointing to development domain, those should now point to prod. Ensure no reference to “localhost” or any test API keys remain. Check that the Terms of Service and Privacy Policy pages are accessible and contain your company name and correct information (sometimes template placeholders like “[COMPANY NAME]” can be forgotten — replace those with Naveeg or your entity name). This is the content that users and possibly journalists or Product Hunt commenters will see, so you want it to be polished.
Support Workflow: Simulate a user support request on the live system. For instance, submit the contact form yourself and ensure you receive it. If you set up an autoresponder, check that it actually sent an email back to the user (you). This verifies that all background workflows (n8n, Zapier, or Supabase triggers) are firing in production. Also be sure that any emails coming from your system (whether from Supabase Auth or your contact form) aren’t going to spam — you might need to add proper SPF/DKIM records if you haven’t (for emails, this might be a longer task, but at least be aware of it).
Post-Launch Monitoring Plan: Confirm that you have access to all monitoring dashboards: Vercel Analytics, Supabase logs, Stripe logs, 10Web status, Sentry errors, etc. In the first 24-48 hours, check these frequently. A good practice is to set up alerts: for example, Sentry can send an email or Slack message if a new error occurs; Stripe can alert on failed payments; Supabase can potentially alert on usage spikes. Even a simple cron job or script to ping your site and see if it’s up (uptime monitoring) can be helpful. While manual checking is okay at first, automating some of this will give you peace of mind when you’re not actively watching.
By completing this deployment validation checklist, you’ll ensure that the production setup of Naveeg is solid. This reduces the chances of any surprises when real users start using the platform. It’s much better for you to catch and fix an issue now in a controlled manner than to scramble after a user reports it. Everything checked? Congrats – you are ready for public launcheverything, 